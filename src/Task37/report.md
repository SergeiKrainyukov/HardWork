## Задание 37

### Пример 1

Требуется сделать экран анкеты в мобильном приложении. Изначальные требования были просты - 
вопросы прилетают с бэкенда, их нужно отобразить списком. Но затем начали появляться дополнительные требования
от бизнеса:
- обязательный/необязательный вопрос
- вопрос, содержащий группу других вопросов (например, поле с адресом, которое разбивается отдельно на
город, улицу, дом и тд)
- вопрос с выбором ответа да/нет
- вопрос с выпадающим списком ответов
- вопрос со списком ответов, но на отдельной странице с поиском и фильтрацией
- вопрос с валидацией/без валидации на клиенте
- порядок вопросов может меняться, должен быть отдельный параметр для порядка

Также был запрет на вертикальную прокрутку страницы, то есть вопросы должны были разбиваться
по отдельным страницам так, чтобы помещаться на экране, и при этом те, которые не помещаются, должны были
переходить на следующую страницу.

При этом, система должна быть настолько динамичной, что клиент абсолютно ничего не знает о том, какие
именно вопросы ему придут, чтобы сохранялась возможность в любой момент убрать/добавить какой-либо
вопрос с одной или несколькими вышеуказанными характеристиками, каждая из которых настраиваемая отдельно
и на клиенте его отобразить по-новому.

Ведущим разработчиком было принято решение сделать единый интерфейс с десятком методов, на его основе
сделать абстрактный класс с пустой реализацией, и далее уже от него наследовать конкретные типы
вопросов. Мне такой подход не очень понравился, так как он нарушает принципы SOLID, я бы сделал наоборот
множество интерфейсов под каждую характеристику, и использовал бы их по необходимости. Система была бы
более гибкой.

### Пример 2

Типичная задача сделать какой-либо запрос к серверу по нажатию на кнопку. В идеальном
мире нужно было бы просто физически сделать запрос по клику и обработать результат. Но в реальном
мире появляются такие краевые случаи, как например долгое время выполнения запроса, в течение которого
пользователь может случайно или намеренно нажать на кнопку несколько раз, и тогда запрос отправится
многократно. В большинстве случаев такого не произойдет, но в единичных произойдет, и надо это
учитывать. Я такие проблемы решаю через передачу состояний в виде enum для кнопки, и когда приходит
новое состояние, то в зависимости от него выставляются нужные параметры у самой кнопки (кликабельность,
цвет и тп).

### Пример 3

Был случай со списком дополнительных продаж при оформлении кредитной карты клиенту. Все виды дополнительных
продаж обрабатываются одинаково, достаточно просто кликнуть согласен/не согласен, но есть отдельный вид
под названием сим-карты, который должен обрабатываться по особой логике. Коллега выбрал просто
проверять строку, пришедшую с сервера, и открывать соответствующий экран, но я бы сделал иерархию
классов.

### Пример 4

При протухании токена некоторый сервис, разработанный другим подразделением банка, выдавал ответ
со статусом 200, вместо стандартного 403. Я долго не мог понять, в чем проблема при разработке новой
фичи, потому что по умолчанию в той библиотеке, которую я использовал, ошибочными статусами считаются
все статусы с 400 по 500. В итоге спросил у коллег, как с этим быть, и оказалось, что нужно было
перехватывать информацию, которая шла вместе с этим статусом, и при наличии определенных данных,
подменять статус 200 на статус 403, чтобы обрабатывать его корректно.

### Выводы

После прочтения статьи появилось несколько идей, как можно было поступить в вышеприведенных случаях.

В первой ситуации надо было обсудить, насколько вообще необходима подобная динамичность системы?
Является ли это ничем необоснованной хотелкой менеджеров или же это обусловлено конкретными
расчетами, и бизнесу действительно выгодно будет иметь функционал в таком виде? У меня возникло
соображение, что было бы куда проще, быстрее и выгоднее не закладывать в архитектуру подобную
изменчивость, потому что анкета по своему существу не будет часто радикально меняться, и 80% вопросов
там будут всегда одинаковые и всегда одного типа (иначе с ней просто будет невозможно работать).
Соответственно, здесь можно было бы пойти по пути сокращения функциональности и стандартизации 
функционала, а краевые случаи просто выводить текстовыми полями и вбивать туда информацию текстом.

Во втором случае уже не получится сократить и стандартизировать функционал, поэтому путь разделения
состояний кнопки в виде отдельных классов считаю наиболее верным.

В третьем случае путь повышения уровней абстракции был бы наиболее предпочтителен, так как в будущем могли
появляться и другие продукты с особой обработкой.

В последнем случае, как мне кажется, была допущена системная ошибка, и ее уже надо решать на уровне
всей системы целиком, иначе придется прибегать к подобным костылям.


