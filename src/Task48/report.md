## Задание 48

### Пример 1

Первоначально архитектура презентационного слоя проекта строилась на использовании паттерна mvvm, который предполагал
наличие View, которая подписана на ViewModel, и занимается отображением данных и реакцией на действия пользователя.
ViewModel хранит всю информацию для View и взаимодействует со слоем бизнес-логики, либо слоем данных напрямую.
Навигация использовалась нативная без каких-либо библиотек.

По мере усложнения проекта и движения в сторону мультиплатформенности решили перейти на использование паттерна
MVI с использованием библиотеки MVIKotlin, а также на новую навигацию с использованием библиотеки Decompose.
Поначалу код стало писать ощутимо сложнее, появилось множество дополнительных сущностей, требующих поддержки,
много Boilerplate кода, однако все это было строго стандартизировано и для всех сценариев шаблон был всегда одинаковый.
В результате такой подход оказался очень удобен для масштабирования системы, хоть и новичку в нем может быть сперва
непривычно разбираться, а также здорово упрощает тестирование. Загнав себя в определенные рамки, мы выработали единый подход к решению задач, который понятен
всем причастным к работе и эффективен для поставленных задач в проекте.

### Пример 2

Была задача добавить ocr для распознавания документов в момент открытия камеры на устройстве. Нужно было распознавать
границы документов, чтобы пользователь не мог сделать кривую/косую фотографию, а делал ровно и корректно.
Наиболее подходящее решение, которое мы подключили в проект, соответствовало на 80% нашим нуждам, но ему недоставало
апи для полного удовлетворения наших запросов. В итоге пришлось написать несколько функций в самой библиотеке, адаптировав
ее под нас. С одной стороны, это могло бы затруднить ее дальнейшую поддержку, так как с выходом новой версии наши
встроенные функции могли бы перестать работать, но с другой, тот результат, который мы получили, полностью нас
удовлетворяет, и вполне вероятно, обновлять библиотеку не придется еще очень длительное время.

### Пример 3

В разных командах использовались разные DI-фреймворки для внедрения зависимостей. В одной команде использовался Koin,
который генерирует зависимости на этапе выполнения, никак не проверяя наличие необходимых классов на этапе компиляции.
Это может привести к потере в производительности, если для какого-то класса нужно генерировать множество зависимостей
одномоментно, и к неочевидным ошибкам, так как если ты забудешь указать какую-то необходимую зависимость в конфигурационном
файле, то компилятор тебе об этом не сообщит. Однако, это очень простой в использовании фреймворк, у него очень
удобный минималистичный синтаксис, позволяющий делать большое количество вещей, не задумываясь о деталях реализации.
Для небольших проектов, он отлично подходит. Однако, как только я попытался прикинуть, как бы я его использовал в
сложных и ответственных проектах на миллионы пользователей, то сразу понял, что лучше использовать более тяжеловесное
решение, но со статической проверкой на этапе компиляции. Выбор пал на Dagger, предоставляющий огромное количество
инструментов, но чуть более сложный в настройке. В итоге при масштабировании и тестировании он оказался даже удобнее,
а к нюансам использования довольно быстро привыкаешь, зато теперь компилятор сразу предупреждает, если что-то не так.

### Пример 4

Ранее проект не использовал какой-либо дизайн-системы, и все компоненты писались самостоятельно вручную. Это давало
определенные премущества, так как нет никаких ограничений, можно из базовых компонентов фреймворка сверстать практически
все что угодно, и в том виде, в котором это будет удобно. Однако, время на разработку таких компонентов каждый раз с нуля,
либо на изменение существующих под конкретный кейс периодически было довольно большим, да и не всегда получалось
сделать так, чтобы во всем приложении был единый дизайн всех экранов, где-то что-то расплывалось, иногда можно
было просто забыть о том, что нужный компонент уже был написан ранее, либо приходилось копировать часть кода, и изменять
другую часть, чтобы как-то переиспользовать компонент. В итоге было принято решение подключить готовую дизайн-систему.
В итоге свободы стало меньше, но удобства разработки стало в разы проще. Дизайнер составляет макеты на основе
тех же самых компонентов, которые ты можешь взять и использовать из коробки, правильно их настроив. Время на разработку
фичей сократилось, однако появилась зависимость от команды разработки дизайн-системы, но так как она не на аутсорсе, а
в основном контуре банка, то если не хватает какого-то компонента или он работает с ошибками, то всегда есть
возможность об этом сообщить и решить проблему.

### Пример 5

В одной из задач с целью оптимизации запросов к сети было принято решение кэшировать данные локально, и затем брать из из локального хранилища на всех необходимых экранах. Однако, со временем система росла и усложнялась, и всю структуру хранить и поддерживать локально становилось все более неудобно и нецелесообразно. В итоге приняли решение все-таки обращаться к сети на определенных экранах, но сделали отдельное легковесное апи для моментального возврата ответа. Данное решение позволило выпилить целый пласт работы с внутренней базой данных и сильно облегчило дальнейшую поддержку и разработку приложения.

### Выводы

Действительно, в процессе работы постоянно приходится искать компромиссы между функциональностью и удобством. В крупных масштабных проектах, как мне кажется, следует делать выбор в сторону функциональности, так как чаще всего стоит задача длительного развития и поддержки, и удобство сейчас может очень дорого стоить в будущем, когда нужно будет добавить в проект новую уникальную функциональность, а  мы будем ограничены удобным, но недостаточно функциональным арсеналом средств. Однако, если проект предполагается небольшим/утилитарным, либо же как временное решения для закрытия какой-то горящей проблемы, то вполне рационально будет делать выбор в пользу удобства и скорости разработки, отдавая себе отчет в том, что проект точно не будет предназначен для решения крупных масштабных задач.