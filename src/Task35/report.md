## Задание 35

Пример 1: Работа с Room (библиотека для работы с базами данных)

Абстракция: Объект доступа к данным (DAO)

```kotlin

// Абстракция: Таблица базы данных с полями id, name и age.
// Бесконечное количество свойств пользователя в реальном мире отображается
// в класс User с полями, необходимыми для работы системы.
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true) val id: Int,
    val name: String,
    val age: Int
)


// Абстракция: Интерфейс доступа к данным.
// Взаимодействуем с таблицей базы данных, предоставляя методы для вставки и извлечения данных.
// При этом реализация взаимодействия с самой базой SQLite скрыта за интерфейсом.
interface BaseDao<T : Any> {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(list: List<T>): List<Long>

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(obj: T): Long

    @Update
    suspend fun update(list: List<T>)

    @Update
    suspend fun update(obj: T)

    @Upsert
    suspend fun upsert(list: List<T>)

}

//Конкретный интерфейс
@Dao
interface UserDao : BaseDao<User>

// Абстракция: База данных.
// Создаем абстракцию базы данных, включая определение DAO и управление версиями базы данных.
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

Почему это хорошая абстракция:

- Позволяет работать с различными объектами базы данных через общий интерфейс, не изменяя основной код.
- Обеспечивает предсказуемое взаимодействие с различными реализациями базы данных.

Пример 2: Работа со списками для отображения

Абстракция: Управление отображением элементов списка на экране

```kotlin
class DiffCallback<T> : DiffUtil.ItemCallback<ListItem<T>>() {
    override fun areItemsTheSame(
        oldItem: ListItem<T>,
        newItem: ListItem<T>,
    ): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(
        oldItem: ListItem<T>,
        newItem: ListItem<T>,
    ): Boolean {
        return oldItem.contentEquals(newItem)
    }
}

interface ListItem<T> {
    val id: Int
    val content: T

    fun contentEquals(item: ListItem<T>): Boolean
}

data class AdaptPlanListItem(
    override val id: Int,
    //другие поля...
) : ListItem<AdaptPlanListItem> {

    override fun contentEquals(item: ListItem<AdaptPlanListItem>) = this == item

    override val content: AdaptPlanListItem
        get() = this

}
```

Почему это хорошая абстракция:

- Универсальность: Можно использовать с любым типом данных, реализующим интерфейс ListItem<T>.
- Модульность: Четко разделены обязанности сравнения идентификаторов и содержимого элементов.
- Простота и читаемость: Код легко понимать и поддерживать благодаря четко определенным методам и интерфейсам.
- Совместимость с DiffUtil: Реализация подходит для использования с DiffUtil в Android, что улучшает производительность
  обновлений списков.

Пример 3: Взаимодействие с сетевыми сервисами с использованием Retrofit

Абстракция: Работа с сетевыми запросами

Retrofit предоставляет хорошие абстракции для работы с HTTP-запросами и RESTful API, удовлетворяя требованиям
обоснованности и точности:

Обоснованность: Абстракции Retrofit позволяют верно отображать операции HTTP на методы интерфейсов и аннотации. Это
обеспечивает интуитивно понятный интерфейс для разработчиков, скрывая низкоуровневые детали реализации.

Точность: Преобразование данных через конвертеры и поддержка асинхронных вызовов позволяют точно и эффективно работать с
данными, обеспечивая корректное отображение операций HTTP-запросов в объекты и методы.

```kotlin
// Абстракция: Модель данных сетевого ответа.
// Абстрагируем сетевой ответ в виде объекта данных, который можно использовать в приложении.
data class UserResponse(val id: Int, val name: String, val age: Int)

// Абстракция: Сетевой сервис.
// Абстрагируем взаимодействие с сетевыми API, предоставляя методы для выполнения HTTP-запросов.
interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") id: Int): UserResponse
}

// Абстракция: Репозиторий данных.
// Абстрагируем источник данных, объединяя локальные и удаленные данные.
class UserRepository(private val apiService: ApiService) {
    suspend fun getUser(id: Int): UserResponse {
        return apiService.getUser(id)
    }
}

```

Пример 4: Корутины в Котлин

Абстракция: Управление асинхронными операциями

Корутины в Kotlin предоставляют удобный и эффективный способ работы с асинхронным и параллельным программированием,
предлагая высокоуровневые абстракции, которые делают код более читаемым и поддерживаемым.
Рассмотрим, как корутины соответствуют требованиям обоснованности и точности,
делая их хорошей абстракцией для асинхронного программирования.

Например, корутины предоставляют безопасные механизмы для взаимодействия с многопоточными данными,
такие как каналы (Channels) и безопасные контексты выполнения (Dispatchers),
что упрощает написание безопасного многопоточного кода.

```kotlin
val channel = Channel<Int>()
CoroutineScope(Dispatchers.Default).launch {
    for (x in 1..5) channel.send(x * x)
    channel.close()
}

runBlocking {
    for (y in channel) println(y)
}
```

При этом, низкоуровневое управление потоками выполнения программы скрыто от пользователя, а также данные абстракции
отделены от абстракции домена и могут быть применены абсолютно в любом контексте.

Пример 5: Управление состоянием экрана с использованием паттерна MVI в библиотеке MVIKotlin

Абстракция: Управление состоянием экрана.

MVIKotlin — это библиотека, созданная Аркадием Ивановым для реализации архитектурного паттерна Model-View-Intent (MVI) в
Kotlin. Она предназначена для упрощения написания чистого и поддерживаемого кода в Android-приложениях. Рассмотрим эту
библиотеку с точки зрения её абстракций, обоснованности и точности, и сравним её с требуемыми качествами хороших
абстракций.

1. Обоснованность (Soundness)
   MVIKotlin предоставляет обоснованные абстракции, которые корректно отображают операции в архитектуре MVI на
   высокоуровневые конструкции.

Model-View-Intent (MVI): Этот паттерн разделяет приложение на три основные компоненты — Model (Модель), View (
Представление) и Intent (Интент).
Это разделение улучшает модульность и тестируемость кода, делая его более понятным и поддерживаемым.

```kotlin
interface MyFeature : Feature<Intent, State, Label>

data class State(val counter: Int)
data class Intent(val increment: Boolean)
data class Label(val message: String)
```

2. Точность (Precision)

MVIKotlin обеспечивает точность в управлении состояниями и событиями в рамках MVI-архитектуры.

Предсказуемость состояния: Паттерн MVI, реализованный в MVIKotlin, обеспечивает однонаправленный поток данных, что
делает состояния предсказуемыми и управляемыми. Это важно для точности отображения логики приложения на абстракции.

```kotlin

store.states()
    .onEach { state ->
// обновление UI на основе нового состояния
        view.render(state)
    }
    .launchIn(lifecycleScope)
```

Изолированность побочных эффектов: MVIKotlin предоставляет механизмы для изолирования побочных эффектов, что улучшает
предсказуемость и тестируемость кода.

```kotlin
class MyFeatureImpl : MyFeature, Feature<Intent, State, Label> by createFeature(
    initialState = State(0),
    reducer = { state, intent -> ... },
    actor = { state, intent -> ... }
)
```

Сохранение состояния: MVIKotlin поддерживает сохранение и восстановление состояния, что обеспечивает точное отображение
состояния приложения при изменении конфигурации или восстановлении после завершения работы.

```kotlin

val store = storeFactory.create(
    initialState = savedInstanceState.getOrDefault(State(0)),
    bootstrapper = ...
)
```

Применение идеи Дейкстры в практике программирования для меня выглядит следующим образом.

Сначала мы должны описать работу программы на третьем логическом уровне, без привязки к конкретным сущностям и коду.
При этом, нужно максимально отбрасывать лишние подробности, не оказывающие существенного влияния на результат работы
системы.
После этого, когда у нас возникло кристально ясное понимание работы системы, можем опускаться на уровень программных 
сущностей, все еще размышляя при этом не на уровне синтаксиса, а на уровне некой "мета-модели" работы программы, но
уже в терминах программирования. Здесь нужно максимально стремиться к тому, чтобы выделить те самые "истинные" абстракции, 
которые будут корректно и точно превращать понятия из реального мира в программисткие сущности, которые так же
будут соответствовать требованиям надежности и точности. Ну и далее уже опускаемся на уровень синтаксиса кода, почти
механически переводя сформированную спецификацию в код на конкретном языке. Если абстракции были выделены верно,
то следовать TDD будет довольно легко, так как функции будут возвращать ровно один и тот же результат при одних и 
тех же данных на вход.

## Выводы

Данное занятие позволило гораздо глубже понять, что же из себя представляет понятие абстракции в программировании. Ранее
имел довольно поверхностное представление об этом, можно сказать на уровне синтаксиса кода. Очень хорошо понял
ограниченность понимания абстракции, когда говорят о ней как о функциях/анти-унификации/упаковке/перенаправлении.
При выполнении данного задания поймал себя на мысли, что хочется как раз это и привести в пример, поэтому долго
думал, как же будет верно. Отлично зашли примеры со IMEI смартфона и числами как абстракциями аппаратного обеспечения,
дали понимание, что означает "X отображается в Y", и что не каждое такое отображение будет являться хорошей абстракцией.