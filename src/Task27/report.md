## Задание 27

[Пример 1](Пример1.md)

[Пример 2](Пример2.md)

[Пример 3](Пример3.md)


### Выводы

Крайне интересное и полезное занятие, раньше ограниченное количество состояний использовал интуитивно, когда это их
использование напрашивалось как бы "само собой". Данный материал помог начать относиться к этому более осознанно и продумывать
систему типов в проекте таким образом, чтобы не допускать ошибочных состояний на уровне системы типов, а не используя
if-else, запутывающие логику и усложняющие понимание и поддержку кода.

В своих примерах я использовал наиболее простой подход для реализации TOP - когда методы класса переводят объект в нужное
состояние путем создания новых объектов состояний (паттерн State). Данный подход на текущем этапе мне наиболее понятен.
Сами состояния во всех примерах представляют собой Sum types, поэтому на этапе компиляции мы всегда точно знаем, что
объект находится только в одном из заранее определенных состояний, и больше ни в каком.

Концепция unique, immutable, shared так же мной использовалась как бы на "интуитивном" уровне, но теперь буду применять
более осознанно.