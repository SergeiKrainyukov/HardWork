## Задание 22
### 1. Зависимость фреймворка
В контексте мобильной разработки мы всегда зависим от особенностей и версий ОС, под которую разрабатываем.
Например, когда мы ведем нативную разработку под Андроид, то мы неизбежно зависим от фреймворка Андроид, и обязаны
пользоваться его апи, чтобы написать работоспособное приложение. Однако, с годами выработались определенные
паттерны разработки, позволяющие снизить эту зависимость и сделать код по возможности платформонезависимым.
Когда в мобильной разработке начал активно применяться подход Clean Architecture, то это позволило снизить зависимость
от платформы только до уровня UI, сделав слои data и domain платформонезависимыми. В последнее время
появилась технология Kotlin Multiplatform, позволяющая вынести весь платформонезависимый код в отдельные
модули и использовать его на других платформах.

Данная практика уже является практически стандартом разработки под андроид, поэтому чаще всего применяется
неосознанно.

### 2. Зависимость расшаренного формата
Рассмотрим пример с обменом данными между двумя приложениями через файл в общей директории.

У нас есть два приложения: Приложение A записывает информацию о пользовательских сессиях 
в общедоступный файл в формате JSON. 
Приложение B (аналитическое приложение) считывает этот файл для анализа данных.

// Формат файла JSON, который использует Приложение A для записи:
```json
{
  "sessions": [
    {
      "sessionId": "abc123",
      "startTime": "2023-04-01T12:00:00Z",
      "endTime": "2023-04-01T12:30:00Z"
    }
  ]
}
```

Приложение B успешно считывает и анализирует эти данные. 
Однако, если Приложение A решает изменить формат файла, добавив новые поля или изменяя 
структуру существующих данных, Приложение B не сможет корректно считывать данные, 
пока не будет обновлено для работы с новым форматом.

Для решения такой зависимости был принят подход с использованием версионирования формата данных. 
Приложение A добавляет информацию о версии формата данных в сам файл:

```json
{
  "formatVersion": "1.0",
  "sessions": []
}
```

Теперь Приложение B может проверять версию формата перед чтением данных и соответствующим образом адаптировать свой код для разных версий формата. 
Это позволяет обоим приложениям работать независимо друг от друга, снижая риск поломки при изменении формата данных.

Данное решение было принято осознанно.

### 3. Зависимость зависимости

У нас есть два модуля в приложении: **Модуль А** (модуль пользовательского интерфейса) и **Модуль B** (модуль сетевых запросов). 
Модуль А использует Модуль B для получения данных из сети и отображения их пользователю. 
Первоначально, оба модуля работают независимо друг от друга, кроме явно определённого интерфейса взаимодействия между ними.
Также в **Модуле B** используется глобальная переменная isNetworkAvailable, которая отслеживает доступность сети.
Эта переменная первоначально использовалась только внутри Модуля B для управления состоянием сетевых запросов.

Неопытный коллега решил изменить логику работы с сетью и сделал isNetworkAvailable доступной для других модулей, 
в частности для отображения сообщения о том, что сеть недоступна в модуле А.

Теперь, Модуль А начинает зависеть от значения isNetworkAvailable из Модуля B. 
Это создаёт неявную зависимость между Модулем А и внутренней логикой Модуля B. 
Если кто-то решит изменить логику работы с переменной isNetworkAvailable в Модуле B 
(например, изменить условия, при которых считается, что сеть доступна), 
это может непредсказуемо повлиять на работу Модуля А.

Для решения этой проблемы использовался следующий подход:
Вместо прямого доступа к глобальным переменным, Модуль B предоставляет специальный интерфейс, который
получает состояние сети. Теперь Модуль А ничего не знает о внутренней реализации модуля В и взаимодействует
с ним так же, как и ранее через интерфейс.

Решение в данном случае было принято осознанно, хотя довольно часто подобный интерфейс создается
на автомате, не задумываясь.

### 4. Зависимость краша.

#### Сценарий

В приложении есть два модуля: **Модуль А** (UI модуль) и **Модуль B** (модуль данных). 
Модуль B отвечает за загрузку данных с сервера и кэширование их локально, в нем используется сторонняя библиотека для запросов в сеть. 
Модуль А отображает эти данные пользователю и не зависит от Модуля B, только через общий репозиторий.

Разработчики решают обновить библиотеку для HTTP запросов, используемую в Модуле B. 
Это обновление вносит изменения в формат ошибок, которые библиотека генерирует при неудачных запросах.
Ранее, при определённых ошибках сети, библиотека возвращала ошибку с определённым кодом, 
который корректно обрабатывался в Модуле B.

После обновления, структура ошибки изменяется, и теперь при определённых условиях ошибка не обрабатывается 
должным образом в Модуле B. Это приводит к тому, что при попытке доступа к некорректно 
обработанным данным из Модуля А (через общий репозиторий данных), приложение крашится 
из-за другой необработанной ошибки.

Для решения проблемы были написаны дополнительные юнит- и интеграционные тесты,
проверяющие различные сценарии работы с данными, включая обработку ошибок. На саму зависимость от
внешней библиотеки это никак не повлияло, однако вероятность подобной проблемы в будущем сильно снизилась.

Решение было принято осознанно

### 5. Зависимость перебрасывания
В Андроид-разработке часто бывает ситуация, когда приложение должно работать как онлайн, так и оффлайн.
При этом, когда сеть недоступна, данные должны браться из бд. Если и в бд данных нет, то выводится
шаблонная страница с предупреждением, что надо включить интернет или сделать что-то иное. Для снижения
зависимости от конкретного источника данных опять же используется Clean Architecture, но об абсолютно
полной независимости UI от Data слоя тут говорить, конечно, нельзя. Данная зависимость просто принимается
как данность, и разрабатываются специальные интерфейсы для инкапсуляции слоя данных, чтобы сократить
зависимости по минимуму.

### 6. Зависимость инверсии
DI в Android-проектах позволяет бывает излишним, когда приложение небольшое, либо когда надо в очень
сжатые сроки предоставить рабочее решение (например, при участии в хакатоне). В первом случае мы плодим
множество интерфейсов в приложении, при этом каждый из них будет иметь всего одну реализацию. Данный
подход упрощает тестирование, но кодовая база из-за этого кажется перегруженной, и теряются все
преимущества DI. Поэтому в небольших проектах, где нет очень сложной логики, стараюсь не плодить
множество лишних сущностей, и делать архитектуру проще. То же относится и к хакатонам и подобным
мероприятиям, где изначально не подразумевается качественно проработанное и технически совершенное
решение, а, наоборот, кто быстрее сделает необходимое количество фичей, тот и победит. Однако в крупных
проектах такой подход все же позволяет упростить жизнь, поэтому прежде чем использовать DI я
анализирую и осозанно принимаю решение о его необходимости в конкретном случае.

### 7. Зависимость зацикливания
Крупное приложение было разделено на модули, каждый из которых содержал некоторые данные, которые
в какой-то момент могли понадобиться другим модулям. Встала проблема, связанная с тем, что двум или более модулям
могут понадобиться данные друг друга для работы. Проект в таком случае даже не компилируется, определяя
сразу циклическую зависимость. Проблема была решена использованием внутренних механизмов Андроид,
позволяющих передавать данные между модулями не напрямую обращаясь к другому модулю, а используя
специальный Content Provider, механизм которого заключается в том, что модуль посылает запрос на
получение данных, которые ему нужны, и система сама определяет, какой модуль эти данные может предоставить,
основываясь на определенном контракте.

Решение было принято осознанно.

### 8. Зависимость высшего порядка
Сам не писал никакие библиотеки, поэтому с точки зрения разработчика какой-то библиотеки не могу привести
пример данного вида зависимости. Однако, знаю случай, когда на одном соревновании по типу хакатона,
ребята с помощью наследования переопределили поведение некоторых классов из стандартной библиотеки
Андроид таким образом, чтобы при запуске приложения смартфон начинал очень сильно греться, но не
перегреваться, чтобы не выйти из строя. Таким образом, получилось приложение "Грелка". Они заняли
первое место за самую оригинальную идею. Поэтому данный вид зависимости, если он есть, может быть
использован для достижения весьма неординарных результатов.

### 9.Зависимость большинства.
В приложении есть синхронизация данных по апи с сервером, которая включает пару сотен таблиц и выполняется
около минуты. Синхронизация считается успешной, если все таблицы были обновлены успешно. Но могут
возникнуть случаи, когда во время синхронизации пропал интернет, смартфон разрядился, либо данные в 
какой-то таблице повреждены. Так как таблицы имеют внутренние связи друг с другом, то даже если одна
таблица синхронизируется неправильно, то это может иметь последствия для всей системы. Так как необходимо,
чтобы все таблицы синхронизировались успешно, было принято решение сделать некий счетчик попыток синхронизации,
который давал бы понять, ошибка произошла случайно из-за внешнего воздействия (связь прервалась, батарея разрядилась и тд)
или же проблема на стороне сервера, и он отдает неправильные данные. В таком случае, если после 3 попыток
не удалось обновить все таблицы без ошибок, то пользователю выводятся предыдущие актуальные данные,
а приложение перестает пытаться обновиться самостоятельно и требует ручного обновления по нажатию на кнопку.

Решение было принято осознанно.

### Выводы

Ранее в голове было довольно сумбурное представление о зависимостях, рассматривал их только в контексте
"если А использует Б, значит А зависит от Б". Занятие позволило очень сильно расширить понимание 
зависимостей, что позволит в будущем принимать более эффективные решения при проектировании систем.
Для того, чтобы привести примеры некоторых зависимостей, пришлось очень долго думать, как конкретно
данный вид зависимости проявляет себя в прикладных проектах на практике, не сразу понял различие между
"зависимостью зависимости" и "зависимостью краша".
