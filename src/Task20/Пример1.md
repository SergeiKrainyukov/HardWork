## Пример 1

### Было
```java
public class GoodRepository extends AbstractPlanLimitator<Good> {
    
    private SparseArray<List<Good>> cacheForGroup;

    private List<Good> getGoodsByGroupId(int groupId) {
        List<Good> result = cacheForGroup.get(groupId, new ArrayList<>());
        if (result.isEmpty()) {
            for (GroupGood groupGood : groupGoodRepository.getGroupGoodByGroupId(groupId)) {
                if (availableGoodId.contains(groupGood.getGoodId()))
                    result.add(getObjectById(groupGood.getGoodId()));
            }
            cacheForGroup.put(groupId, result);
        }
        return result;
    }

}

public class Good implements Updatable, PlanCalculable, Comparable<Good> {
        private int id;
        private String article;
        private String code;
        private String codeErp;
        private String codeFor1C;
        private String codeEAN;
        private String description;
        //...
```


### Стало
```java

```

*Было:* В приложении используется кеш данных, который представляет собой мутабельную коллекцию объектов. При получении объекта из кеша и последующем его изменении, изменения отражаются в самом кеше, что может вызвать нежелательные побочные эффекты и усложнить отладку.

*Стало:* Кеш хранит иммутабельные объекты. Когда данные запрашиваются из кеша, клиентский код получает копии данных, которые не могут быть изменены. Это упрощает управление состоянием, так как любые изменения в данных не повлияют на глобальное состояние кеша.

*Комментарий:* Иммутабельность обеспечивает надежность и предсказуемость работы с кешированными данными, так как любые изменения в объекте не затронут уже сохраненные данные в кеше, что особенно важно в многопоточных приложениях.
