## Задание 21
### 1. Это не баг
1. Мобильное приложение по кнопке "Вернуться" на одном из главных экранов должно сворачиваться, однако
на некоторых экранах оно сворачивается сразу, а на других возникает предупреждение "Нажмите "Назад" еще 
раз для выхода в меню". Такое поведение было сделано специально и обосновано тем, что пользователи
случайно нажимают кнопку "Вернуться" и сворачивают приложение на системно значимых экранах. На старых устройствах
это приводило к убийству процесса операционной системой и потере всех данных, 
поэтому была сделана такая "защита от дурака".
2. Выпустили очередное обновление бд в прод, но не учли все нюансы характеристик товаров в мобильном приложении у
торгового представителя. В итоге у торгового представителя не отображались некоторые товары, которые были
в магазине, и он не мог сделать заказ. Так как решение нужно было принимать срочно, то на уровне приложения
выпустили обновление, где была отключена одна из важных проверок. Необходимые товары появились, но
цена отображалась без учета акций. Это не было сильно критично для оформления заказа и не стопорило
работу, но позволило выиграть необходимое время для исправления ошибки.

### 2. Это не баг (а что-то другое)
1. Структура экрана приложения состояла из одного родительского фрагмента и нескольких вложенных фрагментов.
При этом родитель знал о том, какие конкретно фрагменты в него вложены, а также некоторые вложенные
фрагменты знали о родителе. Никаких ошибок из-за этого не возникало, но это нарушало один из важных
принципов программирования - переиспользование компонентов. Из-за такой сильной связности переиспользовать
эти фрагменты по отдельности в других местах не представлялось возможным, хотя концепция фрагментов для
этого и была придумана.
2. Неопытным программистом был написан код, который оборачивает в try-catch блок кода, создающий корутину.
Это не приводило ни к каким ошибкам, так как код в корутине работал хорошо и безошибочно и никаких проблем
не возникало. Но если бы возникла какая-то ошибка, то try-catch бы не сработал, так как после создания
корутины метод, в котором она была создана, завершает свою работу, а код корутины выполняется в другом
потоке. В данном случае необходимо было использовать специальные механизмы обработки ошибок в корутинах.

### 3. Это сбивает людей с толку
1. В мобильном приложении использовались activity и фрагменты для отрисовки разных экранов. При этом
в названиях самих классов иногда встречалось слово "Page" вместо "Activity" или "Fragment", что сбивало с толку, так как непонятно, это
активити или фрагмент, и как с ним взаимодействовать, так как у них принципиально разное назначение и апи.
2. Невнятное разделение кода по пакетам. Когда нужно быстро найти и исправить ошибку в коде, то простые и
понятные имена пакетов и их содержимое здорово упрощает работу. Но в одном из проектов пакеты ui и presenter
были на одном уровне, хотя архитектурный паттерн mvp целиком относится к слою ui. Также был отдельный пакет
"interfaces", который действительно содержал интерфейсы, вот только назначение их непонятно, пока не
залезешь в код.

### 4. Это хрупкость
1. При разработке экрана по определенному макету не были учтены ошибочные ситуации, и что должно быть
выведено пользователю при их возникновении. В итоге после успешных тестовых кейсов выпустили приложение
в прод, но не учли несколько ошибочных состояний, из-за чего пользователю выводилась либо нерелевантная
информация, либо пустой экран, на котором непонятно что делать.
2. На стороне мобильного приложения был создан сервис, выполняющий в фоне работу по сбору координат пользователя.
Через некоторое время после запуска обнаружилось, что у некоторой части пользователей сбор координат начинался и завершался
не в то время, которое ожидалось. После проведения исследования обнаружилось, что на определенной модели
смартфонов от конкретного производителя стоит ограничение на фоновую работу, которое надо обрабатывать
определенным образом.

### 5. Это не соответствует требованиям OSHA
1. В проекте в разных частях кода использовалась одновременно первая и вторая версия библиотеки rx. Из-за
чего в некоторых местах возникали неоднозначности в том, из какой библиотеки взят тот или иной класс.
Когда нужно было добавить новую функциональность, долго не мог понять, почему класс с одним и тем же
названием ведет себя по-разному и возникают ошибки компиляции. При этом старую версию удалить было нельзя,
так как на ней завязано еще очень много чего. Пришлось потратить на задачу 3 дня, чтобы сделать хоть более-менее корректно и отвлечь старших
разработчиков, хотя мог бы сделать за полдня.
2. Попробовал использовать библиотеку, написанную другим разработчиком в компании. Так как апи было
написано неочевидным образом и использовались имена функций, логика которых не соответствовала напрямую своим
названиям, то получил очень странные и неожиданные результаты. В итоге пришлось вместе с коллегой рефакторить
его решение, чтобы его можно было нормально использовать.

### Выводы
Задание позволило по-новому взглянуть на ошибки и баги в проекте. Раньше имел довольно однобокое представление
об этом в рамках того, что баг - это обязательно то, что работает не так, как ожидается. В данном занятии
речь идет о тех типах багов, которые еще не случились, но с очень большой вероятностью появятся в дальнейшем.
С точки зрения проектирования крайне важно предусматривать все перечисленные случаи, чтобы система
в будущем работала так, как от нее ожидается и ее было легко при этом поддерживать и масштабировать.