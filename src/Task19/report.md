## Задание 19
## Решение

В одном из рабочих проектов была следующая структура таблиц:

Класс `Task`, который имеет поля id и createdDate:
```java
@Entity
public class Task {
    @PrimaryKey
    @NonNull
    private String id;

    private Long createdDate;
    
    //...
}
```

Класс `Attachment`, который содержит путь до файла на устройстве:

```java
@Entity
public class Attachment {
    @PrimaryKey
    @NonNull
    private String id;

    @ColumnInfo
    private String file;
    
    //...
}
```

Класс `TaskAttachment`, который связывает таблицы `Task` и `Attachment`.

```java
public class TaskAttachment {
    @ColumnInfo(name = "task_id")
    @NonNull
    private String taskId;

    @ColumnInfo(name = "attachment_id")
    @NonNull
    private String attachmentId;
    
    //...
}
```

Общая концепция заключалась в том, что на экране будет отображаться список задач, где у каких-то
задач могло быть вложение, а у других нет. Также предполагалось, что у вложений могли быть
какие-то дополнительные параметры. Однако в процессе эксплуатации выяснилось, что вложение
есть у большинства задач, и кроме пути к файлу на устройстве больше никакой дополнительной
информации не требовалось. При этом самих задач могло быть большое множество и открывать
каждую задачу и просматривать вложение было одним из частоиспользуемых сценариев. Но в 
данной структуре приходилось делать дополнительные join'ы, чтобы найти вложение для задачи,
что само по себе замедляет работу системы, хотя в этом нет никакой необходимости. Вполне
логичным решением было бы денормализовать структуру бд и включить путь к файлу непосредственно
в таблицу `Task` для лучшего быстродействия и удобства использования:

```java
@Entity
public class Task {
    @PrimaryKey
    @NonNull
    private String id;

    private Long createdDate;
    
    private String attachmentPath;
    
    //...
}
```

При отсутствии вложения в поле attachmentPath записывалась бы пустая строка и имелся бы
публичный интерфейс hasAttachment() для проверки его наличия.

## Резюме

Данное задание позволило по-иному взглянуть на проектирование отношений между таблицами.
Раньше принимал нормализацию как нечто должное и само собой разумеещееся, теперь понял, что
в некоторых случаях будет удобнее денормализовать отношения между таблицами.

Мои выводы по материалу:

1. Все мутабельные сущности имеют свою идентичность, изменения в одном месте автоматически распространяются на все связанные сущности. Поэтому их нужно рассматривать в контексте совместного использования.
2. Иммутабельность подразумевает отсутствие уникальной идентичности у значений; изменения приводят к созданию новых копий, не затрагивая оригиналы.
3. Работа с иммутабельными структурами требует особых подходов к моделированию данных, таких как добавление уникальных идентификаторов или организация данных в деревья без циклов.
4. Правильно думать об иммутабельности как о неизменяемости по умолчанию, а о мутабельности -- как о дополнительной возможности (которая требует определённого усложнения модели).
5. Нет единого правильного подхода к началу проектирования: Не существует однозначно правильного способа начать проектирование системы, будь то с квестов, локаций или отношений между ними. Выбор зависит от конкретной задачи и предпочтений разработчика. 
6. Денормализация структуры базы данных может значительно ускорить процесс поиска данных, так как это уменьшает количество необходимых операций соединения таблиц. 
7. Лучше избегать передачи значений по ссылкам и работать ближе к декларативной модели, где побочные эффекты отсутствуют или минимизированы. 
8. Взаимодействие с объектами должно ограничиваться чтением их полей и перезаписью ссылок на эти объекты, исключая возможность изменения состояния объекта через доступ к его полям.

